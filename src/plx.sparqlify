Prefix spy:<http://aksw.org/sparqlify/>
Prefix rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix rdfs:<http://www.w3.org/2000/01/rdf-schema#>
Prefix foaf:<http://xmlns.com/foaf/0.1/>
Prefix dc:<http://purl.org/dc/elements/1.1/>
Prefix xsd:<http://www.w3.org/2001/XMLSchema#>
Prefix plx:<http://panlex.org/plx/>
Prefix owl:<http://www.w3.org/2002/07/owl#>


// (ap)
// mappings concerning approvers beeing sources of tranlations stored in
// the ap table
Create View ap As
    Construct {
        ?appr a plx:Approver.
        ?appr plx:registrationDate ?rgdt.
        ?appr plx:label ?labl.
        ?appr plx:uri ?uri.
        ?appr plx:isbn ?isbn.
        ?appr plx:author ?auth.
        ?appr plx:title ?titl.
        ?appr plx:publisher ?publ.
        ?appr plx:yearOfPublication ?year.
        ?appr plx:quality ?qual.
    }
    With
        ?appr = uri(concat(plx:approver, '/', ?ap))
        ?rgdt = typedLiteral(?dt, xsd:date)
        ?labl = plainLiteral(?tt)
        ?uri  = uri(?ur)
        ?isbn = plainLiteral(?bn)
        ?auth = typedLiteral(?au, xsd:string)
        ?titl = typedLiteral(?ti, xsd:string)
        ?publ = plainLiteral(?pb)
        ?year = typedLiteral(?yr, xsd:integer)
        ?qual = typedLiteral(?uq, xsd:integer)
    From
        ap

// (av)
// mappings concerning approver varieties stored in the av table
Create View av As
    Construct {
        ?appr plx:languageVariety ?lvar.
    }
    With
        ?appr = uri(concat(plx:approver, '/', ?ap))
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
    From
        av

// (df)
// mappings concerning definitions (being a textual representation of a
// meaning in a given variety) stored in the df table
Create View df As
    Construct {
        ?defn a plx:Definition.
        ?mean plx:meaningDefinition ?defn.
        ?defn plx:languageVariety ?lvar.
        ?defn plx:text ?text.
    }
    With
        ?defn = uri(concat(plx:definition, '/', ?df))
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?text = plainLiteral(?tt)
    From
        df

// (dn)
// mappings concerning denotations (connecting expressions with meanings)
// stored in the dn table
Create View dn As
    Construct {
        ?deno a plx:Denotation.
        ?deno plx:denotationMeaning ?mean.
        ?deno plx:denotationExpression ?expr.
    }
    With
        ?deno = uri(concat(plx:denotation, '/', ?dn))
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?expr = uri(concat(plx:expression, '/', ?ex))
    From
        dn

// (ex)
// mappings concerning expressions stored in the ex table
Create View ex As
    Construct {
        ?expr a plx:Expression.
        ?expr plx:languageVariety ?lvar.
        ?expr plx:text ?etxt.
        ?expr plx:degradedText ?dtxt.
    }
    With
        ?expr = uri(concat(plx:expression, '/', ?ex))
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?etxt = typedLiteral(?tt, 'xsd:string')
        ?dtxt = typedLiteral(?td, 'xsd:string')
    From
        ex

// (i1)
// ISO 639-3 language name links to lexvo.org
Create View i1 As
    Construct {
        ?iso1 a plx:Iso639-1Code.
        ?iso3 a plx:Iso639-3Code.
        ?iso1 owl:sameAs ?lexvo1.
        ?iso3 owl:sameAs ?lexvo3.
    }
    With
        ?iso1 = uri(concat(plx:iso639-1,'/',?iso1))
        ?iso3 = uri(concat(plx:iso639-3,'/',?iso3))
        ?lexvo1 = uri(concat('http://lexvo.org/id/iso639-1/',?iso1))
        ?lexvo3 = uri(concat('http://lexvo.org/id/iso639-3/',?iso3))
    From
        i1

// (lv)
// mappings concerning language varieties stored in the lv table
Create View lv AS
    Construct {
        ?lvar a plx:LanguageVariety.
        ?lvar plx:belongsToLanguage ?lang.
        ?lvar plx:languageVarietyName ?name
    }
    With
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?lang = uri(concat(plx:language, '/', ?lc))
        ?name = plainLiteral(?tt)
    From
        lv

// (mi)
// mappings concerning meaning identifiers (representing ids of other web
// sites) stored in the mi table
Create View mi As
    Construct {
        ?mean plx:identifier ?labl.
    }
    With
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?labl = plainLiteral(?tt)
    From
        mi

// (mn)
// mappings concerning meanings stored in the mn table
Create View mn As
    Construct {
        ?mean a plx:Meaning.
        ?mean plx:approver ?appr.
    }
    With
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?appr = uri(concat(plx:approver, '/', ?ap))
    From
        mn

// (wc, wcex)
// mappings concerning word classes (verb, noun, pronoun etc.) of a denotation
Create View wc As
    Construct {
        ?wcls a plx:WordClass.
        ?wcls plx:label ?labl.
        ?deno plx:wordClass ?wcls.
    }
    With
        ?wcls = uri(concat(plx:wordClass, '/', ?tt))
        ?labl = plainLiteral(?tt)
        ?deno = uri(concat(plx:denotation, '/', ?dn))
    From
        // TODO: know why there are ~3981405 expressions but only 15 word
        // classes and why there are no direct references to the word classes
        [[SELECT wc.dn, wcex.tt FROM wc JOIN wcex ON wc.ex = wcex.ex]]

// static word class mappings to dbpedia
// TODO: check if there is a LLOD source providing OLIF data
// TODO: this feels like a hack to create static mappings --> ask Aklakan if
//       this is the only way to do so
Create View wc_dbpedia As
    Construct {
        ?plxmisc owl:sameAs ?dbpmisc.  // 01
        ?plxpron owl:sameAs ?dbppron.  // 02
        ?plxaffx owl:sameAs ?dbpaffx.  // 03
        ?plxauxv owl:sameAs ?dbpauxv.  // 04
        ?plxname owl:sameAs ?dbpname.  // 05
        ?plxadjv owl:sameAs ?dbpadjv.  // 06
        ?plxdetr owl:sameAs ?dbpdetr.  // 07
        ?plxverb owl:sameAs ?dbpverb.  // 08
        ?plxpost owl:sameAs ?dbppost.  // 09
        ?plxnoun owl:sameAs ?dbpnoun.  // 10
        ?plxijec owl:sameAs ?dbpijec.  // 11
        ?plxvpar owl:sameAs ?dbpvpar.  // 12
        ?plxprep owl:sameAs ?dbpprep.  // 13
        ?plxadvb owl:sameAs ?dbpadvb.  // 14
        ?plxconj owl:sameAs ?dbpconj.  // 15
    }
    With
        ?plxmisc = uri(concat(plx:wordClass, '/misc'))  // 01
        ?dbpmisc = uri('http://dbpedia.org/resource/Miscellaneous')
        ?plxpron = uri(concat(plx:wordClass, '/pron'))  // 02
        ?dbppron = uri('http://dbpedia.org/resource/Pronoun')
        ?plxaffx = uri(concat(plx:wordClass, '/affx'))  // 03
        ?dbpaffx = uri('http://dbpedia.org/resource/Affix')
        ?plxauxv = uri(concat(plx:wordClass, '/auxv'))  // 04
        ?dbpauxv = uri('http://dbpedia.org/resource/Auxiliary_verb')
        ?plxname = uri(concat(plx:wordClass, '/name'))  // 05
        ?dbpname = uri('http://dbpedia.org/resource/Name')
        ?plxadjv = uri(concat(plx:wordClass, '/adjv'))  // 06
        ?dbpadjv = uri('http://dbpedia.org/resource/Adjective')
        ?plxdetr = uri(concat(plx:wordClass, '/detr'))  // 07
        ?dbpdetr = uri('http://dbpedia.org/resource/Determiner_%28linguistics%29')
        ?plxverb = uri(concat(plx:wordClass, '/verb'))  // 08
        ?dbpverb = uri('http://dbpedia.org/resource/Verb')
        ?plxpost = uri(concat(plx:wordClass, '/post'))  // 09
        ?dbppost = uri('http://dbpedia.org/resource/Postposition')
        ?plxnoun = uri(concat(plx:wordClass, '/noun'))  // 10
        ?dbpnoun = uri('http://dbpedia.org/resource/Noun')
        ?plxijec = uri(concat(plx:wordClass, '/ijec'))  // 11
        ?dbpijec = uri('http://dbpedia.org/resource/Interjection')
        ?plxvpar = uri(concat(plx:wordClass, '/vpar'))  // 12
        ?dbpvpar = uri('http://dbpedia.org/resource/Verb_particle')
        ?plxprep = uri(concat(plx:wordClass, '/prep'))  // 13
        ?dbpprep = uri('http://dbpedia.org/resource/Preposition')
        ?plxadvb = uri(concat(plx:wordClass, '/advb'))  // 14
        ?dbpadvb = uri('http://dbpedia.org/resource/Adverb')
        ?plxconj = uri(concat(plx:wordClass, '/conj'))  // 15
        ?dbpconj = uri('http://dbpedia.org/resource/Conjunction_(grammar)')
    From
        wc
