Prefix spy:<http://aksw.org/sparqlify/>
Prefix rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix rdfs:<http://www.w3.org/2000/01/rdf-schema#>
Prefix foaf:<http://xmlns.com/foaf/0.1/>
Prefix dc:<http://purl.org/dc/elements/1.1/>
Prefix xsd:<http://www.w3.org/2001/XMLSchema#>
Prefix plx:<http://panlex.org/plx/#>
Prefix owl:<http://www.w3.org/2002/07/owl#>


// (ap)
// mappings concerning approvers beeing sources of tranlations stored in
// the ap table
Create View ap As
    Construct {
        ?appr a plx:Approver.
        ?appr plx:registrationDate ?rgdt.
        ?appr plx:label ?labl.
        ?appr plx:uri ?uri.
        ?appr plx:isbn ?isbn.
        ?appr plx:author ?auth.
        ?appr plx:title ?titl.
        ?appr plx:publisher ?publ.
        ?appr plx:yearOfPublication ?year.
        ?appr plx:quality ?qual.
    }
    With
        ?appr = uri(concat(plx:approver, '/', ?ap))
        ?rgdt = typedLiteral(?dt, xsd:date)
        ?labl = plainLiteral(?tt)
        ?uri  = uri(?ur)
        ?isbn = plainLiteral(?bn)
        ?auth = typedLiteral(?au, xsd:string)
        ?titl = typedLiteral(?ti, xsd:string)
        ?publ = plainLiteral(?pb)
        ?year = typedLiteral(?yr, xsd:integer)
        ?qual = typedLiteral(?uq, xsd:integer)
    From
        ap

// (df)
// mappings concerning definitions (being a textual representation of a
// meaning in a given variety) stored in the df table
Create View df As
    Construct {
        ?defn a plx:Definition.
        ?mean plx:meaningDefinition ?defn.
        ?defn plx:variety ?lvar.
        ?defn plx:text ?text.
    }
    With
        ?defn = uri(concat(plx:definition, '/', ?df))
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?text = plainLiteral(?tt)
    From
        df

// (dn)
// mappings concerning denotations (connecting expressions with meanings)
// stored in the dn table
Create View dn As
    Construct {
        ?deno a plx:Denotation.
        ?deno plx:denotationMeaning ?mean.
        ?deno plx:denotationExpression ?expr.
    }
    With
        ?deno = uri(concat(plx:denotation, '/', ?dn))
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?expr = uri(concat(plx:expression, '/', ?ex))
    From
        dn

// (ex)
// mappings concerning expressions stored in the ex table
Create View ex As
    Construct {
        ?expr a plx:Expression.
        ?expr plx:variety ?lvar.
        ?expr plx:text ?etxt.
        ?expr plx:degradedText ?dtxt.
    }
    With
        ?expr = uri(concat(plx:expression, '/', ?ex))
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?etxt = typedLiteral(?tt, 'xsd:string')
        ?dtxt = typedLiteral(?td, 'xsd:string')
    From
        ex

// (lv)
// mappings concerning language varieties stored in the lv table
Create View lv AS
    Construct {
        ?lvar a plx:LanguageVariety.
        ?lvar plx:belongsToLanguage ?lang.
        ?lvar plx:varietyName ?name
    }
    With
        ?lvar = uri(concat(plx:languageVariety, '/', ?lv))
        ?lang = uri(concat(plx:language, '/', ?lc))
        ?name = plainLiteral(?tt)
    From
        lv

// (mi)
// mappings concerning meaning identifiers (representing ids of other web
// sites) stored in the mi table
Create View mi As
    Construct {
        ?mean plx:identifier ?labl.
    }
    With
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?labl = plainLiteral(?tt)
    From
        mi

// (mn)
// mappings concerning meanings stored in the mn table
Create View mn As
    Construct {
        ?mean a plx:Meaning.
        ?mean plx:approver ?appr.
    }
    With
        ?mean = uri(concat(plx:meaning, '/', ?mn))
        ?appr = uri(concat(plx:approver, '/', ?ap))
    From
        mn

// *************************************************************************
// // (i1)
// // ISO 639-3 language name links to lexvo.org
// Create View i1 As
//     Construct {
//         ?iso1 a plx:iso639-1.
//         ?iso1 owl:sameAs ?lexvo1.
//         ?iso3 owl:sameAs ?lexvo3.
//     }
//     With
//         ?iso1 = uri(concat(plx:iso639-1,'/',?iso1))
//         ?iso3 = uri(concat(plx:iso639-3,'/',?iso3))
//         ?lexvo1 = uri(concat('http://lexvo.org/id/iso639-1/',?iso1))
//         ?lexvo3 = uri(concat('http://lexvo.org/id/iso639-3/',?iso3))
//     From
//         i1
// 
// // (lc)
// // mappings concerning language codes
// Create View lc As
//     Construct {
//         ?lc a plx:langCode.
//         ?lc plx:hasLangCodeType ?tp.
//     }
//     With
//         ?lc = uri(concat(plx:langCode,'/',?lc))
//         ?tp = typedLiteral(?tp, xsd:string)
//     From
//         lc
// 
